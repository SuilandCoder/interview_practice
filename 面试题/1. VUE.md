## VUE
### 1. 双向数据绑定问题
#### vue2.0 -> Object.defineProperty()
* 问题：
    1. 需要对原始数据克隆（因为get方法中不能再获取原始数据）；
    2. 需要分别给对象中的每一个属性设置监听；
#### vue3.0 -> new Proxy()
开始讲 Proxy

### 2. JS Bridge 原理
构建`Native`和非`Native`间的双向消息通信通道：
- JS 向 Native 发送消息: 调用相关功能、通知 Native 当前 JS 的相关状态等；
- Native 向 JS 发送消息: 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等；

### 3. vue3.0 新特性
1. 更快更小
2. TypeScript 重构
3. Composition API

#### 3.1.1 Object.defineProperty >  Proxy
* 不需要遍历并修改原始对象
* 可以完全覆盖对象/数组操作
* 可以覆盖更多的数据类型
* 观察更加精准，消耗更少
* 原生 API，速度超快
* 内存减半，速度加倍

#### 3.1.2 重构 Virtual DOM
* 动静结合，精确编译和重新渲染动态的部分
* 支持 tree-shaking，有效减小打包体积

#### 3.2 完全 TypeScript 重构
* 让 Vue 开发团队更轻松 
* 架构更松散灵活，阅读源码更轻松 
* 可以独立使用 Vue 内部模块 
* IDE 支持更好
> 但是也可能导致影响代码编译速度，所以尤雨溪正在开发 vite

#### 3.3 Composition API
将 2.x 中与组件逻辑相关的选项以 API 函数的形式重新设计。

##### 3.3.1 vue2 对象式组件问题
* 难以复用逻辑代码
* 难以拆分超大型组件
* 代码无法被优化/压缩
* 难以进行数据类型推导

##### 3.3.2 Composition API 如何解决
* 纯函数，方便js运行时理解
* 轻松完成 tree-shaking
* 单一组件的代码可以统合在一起
* 不同组件间，可以对象解构及重命名避免命名空间冲突

##### 3.3.3 为什么要 Composition API？
译自尤雨溪的 Twitter

“制定税收法律时，可以使用线性税率，也可以使用递进式税率。评价那种税收制度更公正，要看收入水平不同的人，谁缴的税更多。设计 API 也类似，要看哪些开发人员需要面对更复杂的问题。

作为 API 设计人员，我们的目标和税收系统的谋划者不同：我们希望尽可能少征税，而不是多征税。

所以，如果 90% 的用户能够留在低税率阶段，只有 10% 的用户需要多缴税，在我看来，比大家平摊税负要好得多。

正因为如此，Vue 的 API 是“分层”的：模版和对象式 API 可以满足大部分使用场景，工作得很好，只需要用户投入很少的学习时间。Composition API 和渲染函数需要“缴纳更多的税赋”，但是只有少数开发者需要负担，而他们也将从系统中获取更多收益。

### 4. VUE SSR
#### 4.1 优点
- 更利于 SEO
  - 不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本（Google除外，据说Googlebot可以运行javaScript）。使用了Vue或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取我们的页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。

- 更利于首屏渲染
  - 首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。

#### 4.2 局限

- 服务端压力较大
  - 本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源；
- 开发条件受限
  - 在服务端渲染中，**created和beforeCreate之外的生命周期钩子不可用**，因此项目引用的第三方的库也不可用其它生命周期钩子，这对**引用库的选择产生了很大的限制**；
- 学习成本相对较高
  - 除了对webpack、Vue要熟悉，还需要掌握node、Express相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。








