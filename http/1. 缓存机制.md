## HTTP 缓存机制分析

浏览器缓存优点：

1. 减少冗余的数据传输
2. 减少服务器负担
3. 加快客户端加载网页速度

### 1. HTTP 缓存策略

#### 1.1 无缓存

第一次请求，或者上一次响应头为` Cache-Control: no-store` ：

<img src="http://tvax1.sinaimg.cn/large/5cf483fdgy1ghozs6q7plj20bf0a9dg9.jpg" alt="无缓存"  />

服务器会将页面最后修改时间通过 `Last-Modified` 标识发送给客户端，同时也会生成一个`Etag`给客户端；

#### 1.2 有缓存

当上一次响应头中 `Cache-Control`为以下四种情况时，表示有缓存：

- Public
- Private
- no-cache
- max-age

有缓存的情况下，又分为 `本地缓存` 和 `协商缓存` 两种：

![缓存策略](http://tvax1.sinaimg.cn/large/5cf483fdgy1ghp06ysnnvj20fe0eot9w.jpg)

其中，若缓存未过期，则从缓存读取，属于**本地缓存**；

若缓存过期，则需要将本地缓存数据与服务器进行对比，协商是否使用缓存数据，属于**协商缓存**；

### 2. HTTP 缓存策略三要素

从以上的缓存策略我们可以看出，判断是否缓存的过程分为三步：

1. 是否有缓存？
2. 本地缓存是否过期？
3. 服务器数据是否已经变动？

由此，我们将Http缓存体系分为以下三部分：

![三要素](http://tvax1.sinaimg.cn/large/5cf483fdgy1ghp0hz130kj209308h74m.jpg)

#### 2.1 缓存存储策略

**Cache-Contral** 用来确定 Http 响应内容是否可以被客户端缓存，以及可以被哪些客户端缓存；

1. 没缓存
   - **no-store**
2. 有缓存
   - **Public**：可以被所有用户缓存，包括终端用户和CDN等中间代理服务器；
   - **Private**：只能被终端用户的浏览器缓存，不允许CDN等中间缓存服务器对其缓存；
   - **no-cache**：不建议使用本地缓存，仍然会缓存数据到本地；
   - **max-age**：资源有效期，单位秒;

没缓存，则直接向服务器请求；

有缓存，则需要进一步判断缓存是否过期；

#### 2.2 缓存过期策略

客户端用来确认存储在本地的缓存数据是否已过期，进而决定是否要发请求到服务端获取数据；

**决定客户端是否可直接从本地缓存数据中加载数据并展示（否则就发请求到服务端获取）**

1. **Expires**，指定了缓存数据有效的绝对时间。（比照客户端时间点，所以可能存在差错）

2. **Cache-Control：max-age**，指定缓存数据有效的相对时间，相当于：

   ```js
   Cache-Control:public/private(不太确定具体哪个)
   Expires:客户端时间 + maxAge
   ```

   > Cache-Control : no-cache 和 Cache-Control：max-age=0	等价

![image-20200814102750575](http://tvax4.sinaimg.cn/large/5cf483fdgy1ghq53eyd55j20e506pt96.jpg)

##### 注意：

1. Cache-Control 中指定的缓存过期策略优先级高于 Expires，当它们同时存在的时候，后者会被覆盖掉。
2. 缓存数据标记为已过期只是告诉客户端不能再直接从本地读取缓存了，需要再发一次请求到服务器去确认，并不等同于本地缓存数据从此就没用了，有些情况下即使过期了还是会被再次用到。



#### 2.3 缓存对比策略

将缓存在客户端的数据标识发往服务端，服务端通过标识来判断客户端 缓存数据是否仍有效，进而决定是否要重发数据。

| 上一次响应头  | 请求头            |
| ------------- | ----------------- |
| Last-Modified | If-Modified-Since |
| ETags         | If-None-Match     |

客户端检测到数据过期或浏览器刷新后，往往会重新发起一个 http 请求到服务器，服务器此时并不急于返回数据，而是看请求头有没有带标识（ If-Modified-Since、If-None-Match）过来，如果判断标识仍然有效，则返回304告诉客户端取本地缓存数据来用即可（这里要注意的是你必须要在首次响应时输出相应的头信息（Last-Modified、ETags）到客户端）。至此我们就明白了上面所说的本地缓存数据即使被认为过期，并不等于数据从此就没用了的道理了。

## 参考：

1. [puhongru, HTTP 强缓存和协商缓存](https://segmentfault.com/a/1190000008956069)

2.  [HTTP基于缓存策略三要素分解法](http://caibaojian.com/http-cache-3.html)



