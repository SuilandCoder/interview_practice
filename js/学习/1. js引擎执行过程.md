## JS 引擎执行过程
js引擎执行过程分为三个阶段：
1. **语法分析**
2. **预编译阶段**
3. **执行阶段**
> 浏览器首先按顺序加载由\<script>标签分割的js代码块，加载js代码块完毕后，立刻进入以上三个阶段，然后再按顺序查找下一个代码块，再继续执行以上三个阶段，无论是外部脚本文件（不异步加载）还是内部脚本代码块，都是一样的原理，并且都在同一个全局作用域中。



### 执行阶段：
本文主要分析js引擎执行的第三个阶段–执行阶段，在分析之前我们先思考以下两个问题：
> js是单线程的，为了避免代码解析阻塞使用了异步执行，那么它的异步执行机制是怎么样的？

通过事件循环（Event Loop），理解了事件循环的原理就理解了js的异步执行机制，本文主要介绍。
> js是单线程的，那么是否代表参与js执行过程的线程就只有一个？
不是的，会有四个线程参与该过程，但是永远只有JS引擎线程在执行JS脚本程序，其他的三个线程只协助，不参与代码解析与执行。参与js执行过程的线程分别是：
- JS引擎线程： 也称为JS内核，负责解析执行Javascript脚本程序的主线程（例如V8引擎）
- 事件触发线程： 归属于浏览器内核进程，不受JS引擎线程控制。主要用于控制事件（例如鼠标，键盘等事件），当该事件被触发时候，事件触发线程就会把该事件的处理函数推进事件队列，等待JS引擎线程执行
- 定时器触发线程：主要控制计时器setInterval和延时器setTimeout，用于定时器的计时，计时完毕，满足定时器的触发条件，则将定时器的处理函数推进事件队列中，等待JS引擎线程执行。
> 注：W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms。
- HTTP异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。
> 注：浏览器对通一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个，ie8则为10个。

#### 宏任务
宏任务（macro-task）可分为同步任务和异步任务：
- 同步任务指的是在JS引擎主线程上按顺序执行的任务，只有前一个任务执行完毕后，才能执行后一个任务，形成一个执行栈（函数调用栈）。
- 异步任务指的是不直接进入JS引擎主线程，而是满足触发条件时，相关的线程将该异步任务推进任务队列(task queue)，等待JS引擎主线程上的任务执行完毕，空闲时读取执行的任务，例如异步`Ajax`，`DOM事件`，`setTimeout`等。

#### 微任务
`Promise`， `process.nextTick`
微任务是在es6和node环境中出现的一个任务类型，如果不考虑es6和node环境的话，我们只需要理解宏任务事件循环的执行过程就已经足够了，但是到了es6和node环境，我们就需要理解微任务的执行顺序了。

#### 任务执行
1. 执行宏任务中同步任务，执行结束;
2. 检查是否存在可执行的微任务，有的话执行所有微任务，然后读取任务队列的任务事件，推进主线程形成新的宏任务；没有的话则读取任务队列的任务事件，推进主线程形成新的宏任务;
3. 执行新宏任务的事件任务，再检查是否存在可执行的微任务，如此不断的重复循环;

注意：每个宏任务执行完毕后，会检测当前宏任务下是否有微任务，然后执行微任务，结束后，再从任务队列中取宏任务执行；
![微任务执行流程图](https://tvax3.sinaimg.cn/large/5cf483fdly1ggpevkbmpfj20gl0djtea.jpg)
#### 练习
``` js
// 1
setTimeout(() => {
 Promise.resolve(1).then(console.log);
}, 0);

// 2
setTimeout(() => {
 console.log(2);
}, 0);

//3
console.log(3);

// 输出： 3 1 2
```
解析：最开始任务队列\[3,1,2](任务上方的注释编号，1和2为延迟执行，所以后放入队列)，先执行3，然后执行timeout1，检查有微任务，执行并输出1，然后执行timeout2；所以最后返回 3 1 2；