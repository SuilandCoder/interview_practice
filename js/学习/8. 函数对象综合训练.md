## 题目：
综合考察：
- 变量提升
- this指针指向
- 运算符优先级
- 原型
- 继承
- 全局变量污染
- 对象属性，原型属性优先级
``` js
function Foo() {
    getName = function () { alert (1); };
    return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}
 
//请写出以下输出结果：
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

### 第一问：Foo.getName()
**实际上是访问 Foo 函数上存储的静态属性**
``` js
function User(name){
    var name = name; // 私有属性；
    this.name = name; // 公共属性；
    function getName(){ // 私有方法；
        return name;
    }
}
User.name = 'SongJ' // 静态属性
User.getName = function(){ // 静态方法
    return this.name;
}
var SongJ = new('SongJ') // 实例化
```
注意：
- 调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的；
- 静态方法和静态属性就是我们无需实例化就可以调用
- 而对象的私有方法和属性,外部是不可以访问的

### 第二问：getName()
访问当前上文作用域内的叫getName的函数;
- 变量声明提升
- 函数声明与函数表达式

Javascript中函数声明和函数表达式是存在区别的，**函数声明**在**JS解析时**进行**函数提升**，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而**函数表达式**的值是在**JS运行时**确定，并且在表达式赋值完成后，该函数才能调用。

### 第三问：Foo().getName();
先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。
- 变量作用域
- this 指向问题

Foo函数的第一句getName = function () { alert (1); };是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为function(){alert(1)}。此处实际上是将外层作用域内的getName函数修改了。
> 注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。

### 第四问：getName()
直接调用getName函数，相当于window.getName()，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1，也就是说Foo执行后把全局的getName函数给重写了一次，所以结果就是Foo()执行重写的那个getName函数

### 第五问：new Foo.getName()
**考察的是JS的运算符优先级问题**
- 19 
  - 圆括号 ()
- 18 
  - 成员访问 Person.name
  - 需计算的成员访问 Person[name]
  - new(带参数列表)     new Person()
- 17 
  - 函数调用
  - new(无参数列表)     new Person

``` js
new Foo.getName()
new (Foo.getName)()
```
- 点的优先级(18)比new无参数列表(17)优先级高
- 当点运算完后又因为有个括号()，此时就是变成new有参数列表(18)，所以直接执行new，当然也可能有朋友会有疑问为什么遇到()不函数调用再new呢，那是因为函数调用(17)比new有参数列表(18)优先级低

所以这里实际上将getName函数作为了构造函数来执行，遂弹出2。

### 第六问：new Foo().getName()
``` js
new Foo().getName()
(new Foo()).getName()
```
首先new有参数列表(18)跟点的优先级(18)是同级，同级的话按照从左向右的执行顺序，所以先执行new有参数列表(18)再执行点的优先级(18)，最后再函数调用(17)

#### 构造函数的返回值
在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。
而在JS中构造函数可以有返回值也可以没有。
1. 没有返回值则按照其他语言一样返回实例化对象。
    ``` js
    function Foo(name) {
        this.name = name
    }
    console.log(new Foo('wscats'))
    ```
2. 若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（String,Number,Boolean,Null,Undefined）则与无返回值相同，实际返回其实例化对象。
   ``` js
    function Foo(name) {
        this.name = name
        return 520
    }
    console.log(new Foo('wscats'))
   ```
3. 若返回值是引用类型，则实际返回值为这个引用类型。
   ``` js
    function Foo(name) {
        this.name = name
        return {
            age: 16
        }
    }
    console.log(new Foo('wscats'))
   ```

### 第七问：new new Foo().getName();
``` js
new new Foo().getName();
new ((new Foo()).getName)();
```